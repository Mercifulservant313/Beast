<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Goal Grinder — Single File</title>
<style>
/* ========== Theme variables ========== */
:root{
  --container-max: 1400px;
  --bg:#0b1225; --card:#111827; --text:#e5e7eb; --muted:#9aa3b2;
  --accent:#22c55e; --danger:#ef4444; --border:rgba(148,163,184,.2);
  --shadow: 0 6px 24px rgba(0,0,0,.25);
}
/* Themes */
body.theme-dark{
  --bg:#0b1225; --card:#111827; --text:#e5e7eb; --muted:#9aa3b2;
  --accent:#22c55e; --danger:#ef4444; --border:rgba(148,163,184,.2);
}
body.theme-light{
  --bg:#f6f7fb; --card:#ffffff; --text:#0f172a; --muted:#64748b;
  --accent:#16a34a; --danger:#dc2626; --border:#e5e7eb;
}
body.theme-sepia{
  --bg:#f6f1e5; --card:#fbf7ef; --text:#3b3a36; --muted:#8b816a;
  --accent:#3c7a3c; --danger:#b91c1c; --border:#e9dfcf;
}
body.theme-forest{
  --bg:#0c1712; --card:#13241c; --text:#e7f6ee; --muted:#9fb4aa;
  --accent:#22c55e; --danger:#ef4444; --border:rgba(148,163,184,.18);
}
body.theme-rose{
  --bg:#1a0f15; --card:#23101a; --text:#fde2e9; --muted:#f1a3bb;
  --accent:#f472b6; --danger:#fb7185; --border:rgba(244,114,182,.25);
}

/* ========== Base ========== */
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0; background:linear-gradient(135deg,var(--bg),#121a33);
  color:var(--text); font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
}
a{color:inherit}
h1,h2{margin:0}
button{user-select:none}

/* Top bar */
.topbar{
  display:flex; align-items:center; justify-content:space-between;
  gap:16px; padding:16px; border-bottom:1px solid var(--border);
  position:sticky; top:0; backdrop-filter: blur(6px); z-index:3;
  background:linear-gradient(180deg, rgba(2,6,23,.65), rgba(2,6,23,.4));
}
.topbar .left{display:flex; align-items:center; gap:10px}
.topbar #toggleSidepanel{
  background:#0f172a10; color:var(--text); border:1px solid var(--border);
  border-radius:8px; padding:8px 10px; cursor:pointer;
}
.topbar h1{font-size:22px}
.controls{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
.controls .spacer{width:8px}
.controls input[type="search"], .controls input[type="number"]{
  background:#0f172a10; color:var(--text); border:1px solid var(--border);
  border-radius:8px; padding:8px 10px;
}
.controls button, .panel-header button, .row-buttons button, .ti-buttons button, .panel-footer button{
  background:#0f172a10; color:var(--text); border:1px solid var(--border);
  border-radius:8px; padding:8px 10px; cursor:pointer;
}
.controls button:hover, .panel-header button:hover, .row-buttons button:hover, .ti-buttons button:hover, .panel-footer button:hover{
  border-color:#47556980
}
.controls .danger, .danger{border-color:rgba(239,68,68,.5)}
.controls .import input{display:none}
.controls .import{border:1px dashed var(--border); padding:6px 10px; border-radius:8px; cursor:pointer}

/* Global progress */
.global-progress-wrap{
  display:grid; grid-template-columns:240px 1fr; gap:12px;
  max-width:var(--container-max); margin:12px auto 0; padding:0 16px;
  align-items:center;
}
.gp-left{display:flex; gap:8px; align-items:baseline}
.count-strong{font-weight:700}
.count-muted{color:var(--muted)}
.progress-wide{width:100%}
.progress{width:150px; height:8px; background:#0b122520; border-radius:99px; border:1px solid var(--border); overflow:hidden}
.progress .bar{height:100%; width:0%; background:linear-gradient(90deg,#16a34a,var(--accent))}

/* Main grid */
.grid{
  display:grid; grid-template-columns:2fr 1fr; gap:16px;
  max-width:var(--container-max); margin:16px auto 20px; padding:0 16px;
}
.today-panel{grid-column:1 / -1}

/* Panels */
.panel{
  background:var(--card); border:1px solid var(--border); border-radius:16px; padding:12px; box-shadow: var(--shadow);
}
.panel-header{display:flex; justify-content:space-between; align-items:center; margin-bottom:8px}
.panel-header-right{display:flex; gap:8px; align-items:center}
.panel-footer{display:flex; gap:8px; margin-top:10px}
.muted{color:var(--muted)}

/* Section cards */
.card{
  background:#0f172a10; border:1px solid var(--border); border-radius:14px; margin-bottom:10px; overflow:hidden;
}
.card[draggable="true"] .summary{cursor:grab}
.card.dragging{opacity:.75; outline:2px dashed var(--accent)}
.summary{
  display:flex; justify-content:space-between; align-items:center; gap:8px; padding:10px 12px; cursor:pointer;
}
.summary-left{display:flex; gap:10px; align-items:baseline}
.section-title{font-weight:600}
.count{font-size:13px}
.summary-right{display:flex; gap:8px; align-items:center}
.items{padding:10px 12px 12px}

/* Nested subsections line + drop feedback */
.children{padding:4px 0 0 18px; margin-left:10px; border-left:1px dashed var(--border)}
.children.drophover{border-left-color:var(--accent)}

/* Items */
.item{
  display:grid; grid-template-columns:auto 1fr 110px 1fr auto; gap:8px; align-items:center;
  padding:8px; border-bottom:1px dashed var(--border);
}
.item:last-child{border-bottom:0}
.item input[type="text"]{
  background:#0b122520; color:var(--text); border:1px solid var(--border); border-radius:8px; padding:6px 8px;
}
.row-buttons{display:flex; gap:6px}
.row-buttons .danger{color:#fecaca}

/* Today */
.today-list{display:flex; flex-direction:column; gap:8px}
.today-item{
  display:flex; justify-content:space-between; align-items:center; gap:8px;
  padding:8px; border:1px dashed var(--border); border-radius:10px; background:#0f172a10;
}
.ti-title{font-weight:600}
.ti-duration{font-size:13px}
.ti-buttons{display:flex; gap:6px}

.timer{margin-top:12px; border-top:1px solid var(--border); padding-top:10px}
.timer-row{display:flex; justify-content:space-between; align-items:center; margin-top:6px}
.clock{font-variant-numeric:tabular-nums; font-weight:700}

/* Analytics */
.analytics{display:grid; gap:12px}
.analytics-row{display:flex; gap:16px; flex-wrap:wrap}
.donut-wrap{position:relative; width:220px; height:220px}
.donut-center{
  position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
  font-weight:700; font-size:20px; pointer-events:none;
}
.legend{display:grid; gap:6px; margin-top:4px}
.legend-row{display:flex; align-items:center; gap:8px; font-size:14px}
.legend-row input[type="color"]{width:24px; height:24px; border:none; background:transparent; padding:0}

/* Collapsible sidepanel */
.sidepanel{
  position:fixed; left:12px; top:76px; z-index:10;
  background:var(--card); border:1px solid var(--border); border-radius:12px;
  padding:10px; width:210px; box-shadow:var(--shadow);
  transition: transform .2s ease, opacity .2s ease;
}
.sidepanel.hidden{transform:translateX(-120%); opacity:0; pointer-events:none}
.sidepanel-title{font-weight:700; margin-bottom:6px}
.sidepanel-row{display:flex; align-items:center; justify-content:space-between; gap:8px; margin:6px 0}
.sidepanel-row select{
  background:#0f172a10; color:var(--text); border:1px solid var(--border); border-radius:8px; padding:6px 8px;
  width:120px;
}

@media (max-width: 1200px){
  .sidepanel{display:none}
}
@media (max-width: 980px){
  .grid{grid-template-columns:1fr}
  .global-progress-wrap{grid-template-columns:1fr}
}
</style>
</head>

<body class="theme-dark">
  <!-- Collapsible appearance panel -->
  <aside class="sidepanel" aria-label="Appearance" id="sidepanel">
    <div class="sidepanel-title">Appearance</div>
    <label class="sidepanel-row">
      <span>Theme</span>
      <select id="themeSelect">
        <option value="dark" selected>Dark</option>
        <option value="light">Light</option>
        <option value="sepia">Sepia</option>
        <option value="forest">Forest</option>
        <option value="rose">Rose</option>
      </select>
    </label>
    <label class="sidepanel-row">
      <span>Width</span>
      <select id="widthSelect" title="Content width">
        <option value="1150">Default</option>
        <option value="1400" selected>Wide</option>
        <option value="1600">Ultra</option>
        <option value="9999">Full</option>
      </select>
    </label>
  </aside>

  <!-- Top bar -->
  <header class="topbar">
    <div class="left">
      <button id="toggleSidepanel" title="Show/Hide Appearance">☰</button>
      <h1>Goal Grinder</h1>
    </div>
    <div class="controls">
      <input id="search" type="search" placeholder="Search videos or task…" />
      <label class="goal">
        Daily goal (min):
        <input id="dailyGoal" type="number" min="10" step="5" />
      </label>
      <button id="exportBtn" title="Export data to JSON">Export</button>
      <label class="import">Import <input id="importFile" type="file" accept=".json,.csv" /></label>
      <button id="templateBtn" title="Download a CSV template">Template CSV</button>
      <button id="resetBtn" class="danger" title="Reset all progress">Reset</button>
      <span class="spacer"></span>
      <button id="undoBtn" title="Undo (Ctrl/Cmd+Z)">Undo</button>
      <button id="redoBtn" title="Redo (Ctrl/Cmd+Shift+Z)">Redo</button>
    </div>
  </header>

  <!-- Overall progress -->
  <div class="global-progress-wrap">
    <div class="gp-left">
      <span class="muted">Overall Progress</span>
      <span id="overallCount" class="count-strong">0/0</span>
      <span id="overallPct" class="count-muted">0%</span>
    </div>
    <div class="progress progress-wide">
      <div id="overallBar" class="bar"></div>
    </div>
  </div>

  <!-- Main layout -->
  <main class="grid">
    <!-- Today queue - full width at top -->
    <aside class="panel today-panel" id="todayPanel">
      <div class="panel-header">
        <h2>Today Queue</h2>
        <div class="muted" id="todayMeta"></div>
      </div>

      <div id="todayList" class="today-list"></div>

      <div class="timer">
        <div class="timer-row">
          <span id="activeTaskLabel" class="muted">No active task</span>
          <span id="timerDisplay" class="clock">00:00:00</span>
        </div>
        <div class="timer-row">
          <button id="startTimerBtn">Start</button>
          <button id="pauseTimerBtn">Pause</button>
          <button id="stopTimerBtn">Stop</button>
        </div>
      </div>

      <div class="panel-footer">
        <button id="fillTodayBtn" title="Auto-fill queue up to your goal using uncompleted items">Auto-fill up to goal</button>
        <button id="clearTodayBtn">Clear Today</button>
      </div>

      <div class="stats">
        <div><strong>Studied today:</strong> <span id="studiedToday">0 min</span></div>
        <div><strong>Streak:</strong> <span id="streakDays">0 days</span></div>
      </div>
    </aside>

    <!-- Sections list -->
    <section class="panel">
      <div class="panel-header">
        <h2>Sections</h2>
        <div class="panel-header-right">
          <button id="collapseAllBtn" title="Collapse all sections">Collapse All</button>
          <button id="expandAllBtn" title="Expand all sections">Expand All</button>
          <button id="addSectionBtn">+ Add Section</button>
        </div>
      </div>
      <div id="sections"></div>
      <div class="muted" style="padding:8px 4px 0">
        Bulk format: <code>Section</code> (or a Section Path like <code>Sketchy > Micro > Bacteria</code>), <code>Title</code>, <code>Duration</code> (mm:ss or hh:mm:ss), <code>Notes</code>.
      </div>
    </section>

    <!-- Analytics panel -->
    <section class="panel" id="analyticsPanel">
      <div class="panel-header">
        <h2>Analytics</h2>
      </div>
      <div class="analytics">
        <div class="analytics-row">
          <div><strong>Total Video Duration:</strong> <span id="totalDuration">0:00</span></div>
          <div><strong>Watched:</strong> <span id="watchedDuration">0:00</span></div>
        </div>

        <div class="donut-wrap">
          <svg id="pieChart" viewBox="0 0 220 220" width="220" height="220" aria-label="Watched by section"></svg>
          <div id="pieCenter" class="donut-center">0%</div>
        </div>

        <div id="legend" class="legend"></div>
      </div>
    </section>
  </main>

  <!-- Templates (used by JS) -->
  <template id="sectionTmpl">
    <details class="card" open draggable="true">
      <summary class="summary">
        <div class="summary-left">
          <span class="section-title"></span>
          <span class="count muted"></span>
        </div>
        <div class="summary-right">
          <div class="progress"><div class="bar"></div></div>
          <button class="addChild" title="Add a nested subsection">+ Subsection</button>
          <button class="indent" title="Indent (make child of previous)">▶</button>
          <button class="outdent" title="Outdent (promote up one level)">◀</button>
          <button class="addItem">+ Add Item</button>
          <button class="rename">Rename</button>
          <button class="delete danger">Delete</button>
        </div>
      </summary>
      <div class="items"></div>
      <div class="children droptarget"></div>
    </details>
  </template>

  <template id="itemTmpl">
    <div class="item">
      <input type="checkbox" class="done" />
      <input type="text" class="title" />
      <input type="text" class="duration" placeholder="mm:ss or hh:mm:ss" />
      <input type="text" class="notes" placeholder="notes (optional)" />
      <div class="row-buttons">
        <button class="toToday" title="Add to Today Queue">To Today</button>
        <button class="moveUp" title="Move up">↑</button>
        <button class="moveDown" title="Move down">↓</button>
        <button class="remove danger" title="Delete item">Delete</button>
      </div>
    </div>
  </template>

  <template id="todayItemTmpl">
    <div class="today-item">
      <span class="ti-title"></span>
      <span class="ti-duration muted"></span>
      <div class="ti-buttons">
        <button class="start">Start</button>
        <button class="up">↑</button>
        <button class="down">↓</button>
        <button class="remove danger">Remove</button>
      </div>
    </div>
  </template>

<script>
/* ================== SAFE SINGLE-FILE APP ================== */
const LS_KEY    = "gg_state_v1";
const THEME_KEY = "gg_theme";
const WIDTH_KEY = "gg_container";
const SIDEPANEL_KEY = "gg_sidepanel_hidden";

/* -------- Helpers -------- */
function cryptoId(){ try{ if (crypto && crypto.randomUUID) return crypto.randomUUID(); }catch{} return "id-"+Math.random().toString(36).slice(2,10); }
function todayISO(){ return new Date().toISOString().slice(0,10); }
function asMinutes(hms){ if(!hms) return 0; const p=hms.split(":").map(Number); if(p.some(isNaN)) return 0; if(p.length===3){const[h,m,s]=p;return h*60+m+Math.round(s/60)} if(p.length===2){const[m,s]=p;return m+Math.round(s/60)} if(p.length===1){return Number(p[0])||0} return 0; }
function toSeconds(hms){ if(!hms) return 0; const p=hms.split(":").map(Number); if(p.some(isNaN)) return 0; if(p.length===3){const[h,m,s]=p;return h*3600+m*60+s} if(p.length===2){const[m,s]=p;return m*60+s} if(p.length===1){return Number(p[0])*60||0} return 0; }
function formatHMS(secs){ const h=Math.floor(secs/3600), m=Math.floor((secs%3600)/60), s=secs%60; const pad=n=>String(n).padStart(2,"0"); return `${pad(h)}:${pad(m)}:${pad(s)}`; }
function formatHM(secs){ const h=Math.floor(secs/3600), m=Math.floor((secs%3600)/60); return h?`${h}h ${String(m).padStart(2,"0")}m`:`${m}m`; }
function hash(str){ let h=0; for(let i=0;i<str.length;i++){ h=((h<<5)-h)+str.charCodeAt(i); h|=0; } return h; }

/* -------- Default data (empty) -------- */
const DEFAULT_DATA = {
  settings:{ dailyGoalMinutes:120, sectionColors:{}, collapsed:{} },
  sections:[],
  today:{ date: todayISO(), queue: [], active: null, studiedSeconds:0 },
  history:{}
};

/* -------- Undo / Redo -------- */
const UNDO_MAX = 80;
let undoStack = [];
let redoStack = [];
function pushUndo(){
  try{ undoStack.push(JSON.stringify(state)); if (undoStack.length>UNDO_MAX) undoStack.shift(); redoStack.length = 0; }catch{}
}
function onUndo(){
  if (!undoStack.length) return;
  try{
    redoStack.push(JSON.stringify(state));
    state = JSON.parse(undoStack.pop());
    persist(state, {noHistory:true});
    renderAll();
  }catch{}
}
function onRedo(){
  if (!redoStack.length) return;
  try{
    undoStack.push(JSON.stringify(state));
    state = JSON.parse(redoStack.pop());
    persist(state, {noHistory:true});
    renderAll();
  }catch{}
}

/* -------- State load -------- */
let state = loadState();
function loadState(){
  const raw = localStorage.getItem(LS_KEY);
  if (!raw){
    const starter = structuredClone(DEFAULT_DATA);
    persist(starter, {noHistory:true});
    return starter;
  }
  try{
    const s = JSON.parse(raw);
    if (!s.today || s.today.date !== todayISO()){
      s.today = { date: todayISO(), queue: [], active: null, studiedSeconds: 0 };
    }
    s.settings = s.settings || {};
    s.settings.dailyGoalMinutes ??= 120;
    s.settings.sectionColors ??= {};
    s.settings.collapsed ??= {};
    s.history ??= {};
    return s;
  }catch{
    persist(DEFAULT_DATA, {noHistory:true});
    return structuredClone(DEFAULT_DATA);
  }
}
function persist(s=state, opts={}){
  if (!opts.noHistory) pushUndo();
  localStorage.setItem(LS_KEY, JSON.stringify(s));
}

/* -------- Elements -------- */
const sectionsEl = document.getElementById("sections");
const searchEl = document.getElementById("search");
const dailyGoalEl = document.getElementById("dailyGoal");
const exportBtn = document.getElementById("exportBtn");
const importFile = document.getElementById("importFile");
const resetBtn = document.getElementById("resetBtn");
const addSectionBtn = document.getElementById("addSectionBtn");
const fillTodayBtn = document.getElementById("fillTodayBtn");
const clearTodayBtn = document.getElementById("clearTodayBtn");
const todayListEl = document.getElementById("todayList");
const todayMetaEl = document.getElementById("todayMeta");
const activeTaskLabel = document.getElementById("activeTaskLabel");
const timerDisplay = document.getElementById("timerDisplay");
const startTimerBtn = document.getElementById("startTimerBtn");
const pauseTimerBtn = document.getElementById("pauseTimerBtn");
const stopTimerBtn = document.getElementById("stopTimerBtn");
const undoBtn = document.getElementById("undoBtn");
const redoBtn = document.getElementById("redoBtn");
const collapseAllBtn = document.getElementById("collapseAllBtn");
const expandAllBtn = document.getElementById("expandAllBtn");
const overallPctEl = document.getElementById("overallPct");
const overallCountEl = document.getElementById("overallCount");
const overallBarEl = document.getElementById("overallBar");
const studiedTodayEl = document.getElementById("studiedToday");
const streakDaysEl = document.getElementById("streakDays");
const totalDurationEl = document.getElementById("totalDuration");
const watchedDurationEl = document.getElementById("watchedDuration");
const pieChartEl = document.getElementById("pieChart");
const pieCenterEl = document.getElementById("pieCenter");
const legendEl = document.getElementById("legend");
const templateBtn = document.getElementById("templateBtn");
const themeSelect = document.getElementById("themeSelect");
const widthSelect = document.getElementById("widthSelect");
const sidepanel = document.getElementById("sidepanel");
const toggleSidepanel = document.getElementById("toggleSidepanel");
const sectionTmpl = document.getElementById("sectionTmpl");
const itemTmpl = document.getElementById("itemTmpl");
const todayItemTmpl = document.getElementById("todayItemTmpl");

/* -------- Init -------- */
applyTheme(localStorage.getItem(THEME_KEY) || "dark");
applyContainerWidth(parseInt(localStorage.getItem(WIDTH_KEY) || "1400", 10));
if (localStorage.getItem(SIDEPANEL_KEY) === "1") sidepanel.classList.add("hidden");
renderAll();
setupEvents();
setupDragAndDrop();
tickTimer(); setInterval(tickTimer, 1000);

/* -------- Render -------- */
function renderAll(){
  dailyGoalEl.value = state.settings.dailyGoalMinutes ?? 120;
  renderSections();
  renderToday();
  renderStats();
  renderAnalytics();
}

/* Sections (hierarchical) */
let selectedSectionId = null;
function renderSections(){
  sectionsEl.innerHTML = "";
  const q = (searchEl.value || "").trim().toLowerCase();
  (state.sections||[]).forEach(sec => {
    sectionsEl.appendChild(renderSection(sec, 0, q));
  });
}
function renderSection(sec, depth, q){
  const el = sectionTmpl.content.firstElementChild.cloneNode(true);
  const detailsEl = el; // <details>
  detailsEl.dataset.secId = sec.id;

  const titleEl = el.querySelector(".section-title");
  const countEl = el.querySelector(".count");
  const progressEl = el.querySelector(".progress .bar");
  const itemsWrap = el.querySelector(".items");
  const childrenWrap = el.querySelector(".children");

  titleEl.textContent = sec.title;

  // selection highlight for Tab indent/outdent
  el.querySelector("summary").addEventListener("click", () => {
    selectedSectionId = sec.id;
    el.style.boxShadow = "0 0 0 2px var(--accent)";
    setTimeout(()=> el.style.boxShadow="", 140);
  });

  // Counts & progress
  const items = sec.items || [];
  const visibleItems = items.filter(it => matchesQuery(it, q));
  const secTotalSecs = sumSectionTotalSecondsDeep(sec);
  const [doneCount, totalCount] = countDoneTotalDeep(sec);
  const pct = totalCount ? Math.round(100*doneCount/totalCount) : 0;
  progressEl.style.width = pct + "%";
  countEl.textContent = `${visibleItems.length}/${items.length} shown • TRT ${formatHM(secTotalSecs)}`;

  // Section controls
  el.querySelector(".addItem").addEventListener("click", () => addItem(sec.id));
  el.querySelector(".rename").addEventListener("click", () => renameSection(sec.id));
  el.querySelector(".delete").addEventListener("click", () => deleteSection(sec.id));
  el.querySelector(".addChild").addEventListener("click", () => addSubsection(sec.id));
  el.querySelector(".indent").addEventListener("click", () => indentSection(sec.id));
  el.querySelector(".outdent").addEventListener("click", () => outdentSection(sec.id));

  // Persist collapsed state
  detailsEl.open = !isCollapsed(sec.id);
  detailsEl.addEventListener("toggle", () => setCollapsed(sec.id, !detailsEl.open));

  // Render items
  visibleItems.forEach(it=>{
    const row = itemTmpl.content.firstElementChild.cloneNode(true);
    const doneEl = row.querySelector(".done");
    const titleIn = row.querySelector(".title");
    const durIn = row.querySelector(".duration");
    const notesIn = row.querySelector(".notes");

    doneEl.checked = !!it.done;
    titleIn.value = it.title || "";
    durIn.value = it.duration || "";
    notesIn.value = it.notes || "";

    doneEl.addEventListener("change", ()=>{ pushUndo(); it.done = doneEl.checked; removeFromToday(sec.id, it.id, false); persist(); renderAll(); });
    titleIn.addEventListener("input", ()=>{ it.title = titleIn.value; persist(undefined,{noHistory:true}); });
    durIn.addEventListener("input", ()=>{ it.duration = durIn.value; persist(undefined,{noHistory:true}); renderAll(); });
    notesIn.addEventListener("input", ()=>{ it.notes = notesIn.value; persist(undefined,{noHistory:true}); });

    row.querySelector(".toToday").addEventListener("click", ()=> addToToday(sec.id, it.id));
    row.querySelector(".remove").addEventListener("click", ()=> deleteItem(sec.id, it.id));
    row.querySelector(".moveUp").addEventListener("click", ()=> moveItem(sec.id, it.id, -1));
    row.querySelector(".moveDown").addEventListener("click", ()=> moveItem(sec.id, it.id, +1));

    itemsWrap.appendChild(row);
  });

  // Render children
  (sec.children||[]).forEach(child => {
    const childEl = renderSection(child, depth+1, q);
    childrenWrap.appendChild(childEl);
  });

  // enable DnD hooks
  addDnDHandlers(el, sec);

  return el;
}

/* Today */
function renderToday(){
  todayListEl.innerHTML = "";
  state.today.queue.forEach((q, idx)=>{
    const sec = findSection(q.sectionId); if (!sec) return;
    const it = (sec.items||[]).find(x=>x.id===q.itemId); if (!it) return;
    const row = todayItemTmpl.content.firstElementChild.cloneNode(true);
    row.querySelector(".ti-title").textContent = it.title;
    row.querySelector(".ti-duration").textContent = it.duration || "--:--";
    row.querySelector(".start").addEventListener("click", ()=> startTimer(q.sectionId, q.itemId));
    row.querySelector(".up").addEventListener("click", ()=> moveToday(idx, -1));
    row.querySelector(".down").addEventListener("click", ()=> moveToday(idx, +1));
    row.querySelector(".remove").addEventListener("click", ()=> removeFromToday(q.sectionId, q.itemId));
    todayListEl.appendChild(row);
  });
  renderTodayMeta();
  renderTimerUI();
}
function renderTodayMeta(){
  const goal = Number(state.settings.dailyGoalMinutes || 0);
  const planned = totalPlannedMinutes(state.today.queue);
  todayMetaEl.textContent = `Planned: ${planned} min  |  Goal: ${goal} min`;
}

/* Stats */
function renderStats(){
  const [done,total] = totalDoneOverallDeep();
  const pct = total ? Math.round(100*done/total) : 0;
  overallPctEl.textContent = pct + "%";
  overallCountEl.textContent = `${done}/${total}`;
  overallBarEl.style.width = pct + "%";
  const studiedMin = Math.round((state.today.studiedSeconds||0)/60);
  studiedTodayEl.textContent = `${studiedMin} min`;
  streakDaysEl.textContent = `${calcStreak()} days`;
}

/* Analytics */
function renderAnalytics(){
  const totals = computeTotals();
  totalDurationEl.textContent = formatHM(totals.totalSecs);
  watchedDurationEl.textContent = formatHM(totals.watchedSecs);
  const pct = totals.totalSecs ? Math.round(100*totals.watchedSecs/totals.totalSecs) : 0;
  pieCenterEl.textContent = `${pct}%`;

  const slices = [];
  totals.perTopSection.forEach(s=>{
    if (s.watchedSecs > 0) slices.push({ label:s.title, seconds:s.watchedSecs, color:getSectionColor(s.id,s.title) });
  });
  const remaining = Math.max(0, totals.totalSecs - totals.watchedSecs);
  if (remaining > 0) slices.push({ label:"Remaining", seconds:remaining, color:"#334155" });
  drawDonut(pieChartEl, slices);

  legendEl.innerHTML = "";
  totals.perTopSection.forEach(s=>{
    const row = document.createElement("div");
    row.className = "legend-row";
    const input = document.createElement("input");
    input.type = "color";
    input.value = getSectionColor(s.id, s.title);
    input.addEventListener("input", (e)=>{ setSectionColor(s.id, e.target.value); renderAnalytics(); });
    const label = document.createElement("span");
    label.textContent = `${s.title} — ${formatHM(s.watchedSecs)} / ${formatHM(s.totalSecs)}`;
    row.appendChild(input); row.appendChild(label);
    legendEl.appendChild(row);
  });
}
function computeTotals(){
  let totalSecs=0, watchedSecs=0;
  const perTopSection = (state.sections||[]).map(sec=>{
    const total = sumSectionTotalSecondsDeep(sec);
    const watched = sumSectionWatchedSecondsDeep(sec);
    totalSecs += total; watchedSecs += watched;
    return { id:sec.id, title:sec.title, totalSecs:total, watchedSecs:watched };
  });
  return { totalSecs, watchedSecs, perTopSection };
}
function drawDonut(svg, slices){
  const cx=110, cy=110, R=100, r=62;
  const total = slices.reduce((a,b)=>a+b.seconds,0) || 1;
  while (svg.firstChild) svg.removeChild(svg.firstChild);
  let a0 = -Math.PI/2;
  slices.forEach(s=>{
    const a1 = a0 + (s.seconds/total)*Math.PI*2;
    const path = document.createElementNS("http://www.w3.org/2000/svg","path");
    path.setAttribute("d", donutPath(cx,cy,R,r,a0,a1));
    path.setAttribute("fill", s.color);
    svg.appendChild(path);
    a0 = a1;
  });
  function donutPath(cx,cy,R,r,a0,a1){
    const large = (a1-a0) > Math.PI ? 1 : 0;
    const x0=cx+R*Math.cos(a0), y0=cy+R*Math.sin(a0);
    const x1=cx+R*Math.cos(a1), y1=cy+R*Math.sin(a1);
    const x2=cx+r*Math.cos(a1), y2=cy+r*Math.sin(a1);
    const x3=cx+r*Math.cos(a0), y3=cy+r*Math.sin(a0);
    return `M ${x0} ${y0} A ${R} ${R} 0 ${large} 1 ${x1} ${y1} L ${x2} ${y2} A ${r} ${r} 0 ${large} 0 ${x3} ${y3} Z`;
  }
}
function getSectionColor(id,title){
  const map = state.settings.sectionColors || {};
  if (map[id]) return map[id];
  const palette = ["#ef4444","#22c55e","#06b6d4","#f59e0b","#a855f7","#14b8a6","#e11d48","#84cc16","#3b82f6","#f97316"];
  const idx = Math.abs(hash(title||"")) % palette.length;
  const c = palette[idx]; setSectionColor(id,c); return c;
}
function setSectionColor(id,c){
  state.settings.sectionColors = state.settings.sectionColors || {};
  state.settings.sectionColors[id] = c; persist(undefined,{noHistory:true});
}

/* -------- CRUD -------- */
function addSection(){
  const title = prompt("Section name (eg, Sketchy Micro):");
  if (!title) return;
  pushUndo();
  (state.sections).push({ id: cryptoId(), title, items: [], children: [] });
  persist(); renderAll();
}
function addSubsection(parentId){
  const parent = findSection(parentId); if (!parent) return;
  const title = prompt("Subsection name:"); if (!title) return;
  pushUndo();
  parent.children = parent.children || [];
  parent.children.push({ id: cryptoId(), title, items: [], children: [] });
  persist(); renderAll();
}
function renameSection(secId){
  const sec = findSection(secId); if (!sec) return;
  const title = prompt("Rename section:", sec.title);
  if (!title) return;
  pushUndo();
  sec.title = title; persist(); renderAll();
}
function deleteSection(secId){
  if (!confirm("Delete this section (and all nested subsections/items)?")) return;
  const ctx = findSectionCtx(secId); if (!ctx) return;
  pushUndo();
  // Remove any of its items from Today queue
  const itemPairs = collectSectionItemPairsDeep(ctx.node);
  for (const {sectionId,itemId} of itemPairs) removeFromToday(sectionId, itemId, false);
  // Remove from parent children/root
  if (ctx.parent){
    ctx.parent.children = ctx.parent.children.filter(s => s.id !== secId);
  }else{
    state.sections = state.sections.filter(s => s.id !== secId);
  }
  persist(); renderAll();
}
function addItem(secId){
  const sec = findSection(secId); if (!sec) return;
  const title = prompt("Item title:"); if (!title) return;
  pushUndo();
  sec.items = sec.items || [];
  sec.items.push({ id: cryptoId(), title, duration: "", notes: "", done: false });
  persist(); renderAll();
}
function deleteItem(secId, itemId){
  const sec = findSection(secId); if (!sec) return;
  pushUndo();
  sec.items = (sec.items||[]).filter(i => i.id !== itemId);
  removeFromToday(secId, itemId, false);
  persist(); renderAll();
}
function moveItem(secId, itemId, dir){
  const sec = findSection(secId); if (!sec) return;
  const items = sec.items || [];
  const idx = items.findIndex(i=>i.id===itemId); if (idx<0) return;
  const j = idx + dir; if (j<0 || j>=items.length) return;
  pushUndo();
  [items[idx], items[j]] = [items[j], items[idx]];
  persist(); renderAll();
}

/* -------- Indent / Outdent (sections) -------- */
function indentSection(secId){
  const ctx = findSectionCtx(secId); if (!ctx) return;
  const siblings = ctx.siblings;
  const idx = siblings.findIndex(s=>s.id===secId);
  if (idx <= 0) return; // no previous sibling to become parent
  pushUndo();
  const prev = siblings[idx-1];
  siblings.splice(idx,1);
  prev.children = prev.children || [];
  prev.children.push(ctx.node);
  persist(); renderAll();
}
function outdentSection(secId){
  const ctx = findSectionCtx(secId); if (!ctx || !ctx.parentCtx) return;
  pushUndo();
  const parent = ctx.parentCtx.node;
  const grandCtx = ctx.parentCtx;
  // remove from current parent's children
  parent.children = (parent.children||[]).filter(s => s.id!==secId);
  // insert after parent in grandparent's list (or root)
  if (grandCtx.parent){ // has grandparent
    const gpChildren = grandCtx.parent.children;
    const pIdx = gpChildren.findIndex(s=>s.id===parent.id);
    gpChildren.splice(pIdx+1,0,ctx.node);
  }else{
    const root = state.sections;
    const pIdx = root.findIndex(s=>s.id===parent.id);
    root.splice(pIdx+1,0,ctx.node);
  }
  persist(); renderAll();
}

/* -------- Today Queue -------- */
function addToToday(sectionId, itemId){
  const sec = findSection(sectionId); if (!sec) return;
  const it = (sec.items||[]).find(i => i.id===itemId); if (!it || it.done) return;
  if (!state.today.queue.find(q => q.sectionId===sectionId && q.itemId===itemId)){
    pushUndo();
    state.today.queue.push({sectionId, itemId}); persist(); renderToday();
  }
}
function removeFromToday(sectionId, itemId, rerender=true){
  state.today.queue = state.today.queue.filter(q => !(q.sectionId===sectionId && q.itemId===itemId));
  if (state.today.active && state.today.active.sectionId===sectionId && state.today.active.itemId===itemId){
    state.today.active = null;
  }
  persist(undefined,{noHistory:true}); if (rerender) renderToday();
}
function moveToday(idx, dir){
  const j = idx + dir; if (j<0 || j>=state.today.queue.length) return;
  pushUndo();
  [state.today.queue[idx], state.today.queue[j]] = [state.today.queue[j], state.today.queue[idx]];
  persist(); renderToday();
}
function clearTodayQueue(){ pushUndo(); state.today.queue=[]; state.today.active=null; state.today.studiedSeconds = state.today.studiedSeconds || 0; persist(); renderToday(); }
function autoFillToday(){
  const goal = Number(state.settings.dailyGoalMinutes||0); if (!goal) return;
  pushUndo();
  const remaining = uncompletedItemsDeep(); let minutes = totalPlannedMinutes(state.today.queue);
  for (const {sec,it} of remaining){
    if (minutes >= goal) break;
    if (!state.today.queue.find(q => q.sectionId===sec.id && q.itemId===it.id)){
      state.today.queue.push({sectionId: sec.id, itemId: it.id});
      minutes += asMinutes(it.duration || "0");
    }
  }
  persist(); renderToday();
}

/* -------- Timer -------- */
function startTimer(sectionId, itemId){
  const sec = findSection(sectionId); if (!sec) return;
  const it = (sec.items||[]).find(x=>x.id===itemId); if (!it) return;
  pushUndo();
  state.today.active = { sectionId, itemId, startedAt: Date.now(), elapsed: 0 };
  persist(); renderTimerUI(); setActiveLabel(it.title);
}
function pauseTimer(){
  if (!state.today.active) return;
  const delta = Math.floor((Date.now() - state.today.active.startedAt)/1000);
  state.today.active.elapsed += delta; state.today.active.startedAt = Date.now();
  state.today.studiedSeconds += delta; persist(undefined,{noHistory:true}); renderTimerUI(); renderStats();
}
function stopTimer(){
  if (!state.today.active) return;
  const delta = Math.floor((Date.now() - state.today.active.startedAt)/1000);
  state.today.studiedSeconds += delta;
  const {sectionId, itemId} = state.today.active;
  const sec = findSection(sectionId); if (sec){ const it = (sec.items||[]).find(i=>i.id===itemId); if (it) it.done = true; }
  removeFromToday(sectionId, itemId, false);
  state.today.active = null;
  persist(); renderAll();
}
function renderTimerUI(){
  if (!state.today.active){ setActiveLabel("No active task"); timerDisplay.textContent = "00:00:00"; return; }
  const secs = Math.floor((Date.now() - state.today.active.startedAt)/1000) + (state.today.active.elapsed||0);
  timerDisplay.textContent = formatHMS(secs);
  const it = getItem(state.today.active.sectionId, state.today.active.itemId);
  setActiveLabel(it ? it.title : "Active task");
}
function tickTimer(){
  if (!state.today.active){ timerDisplay.textContent = "00:00:00"; return; }
  const secs = Math.floor((Date.now() - state.today.active.startedAt)/1000) + (state.today.active.elapsed||0);
  timerDisplay.textContent = formatHMS(secs);
}
function setActiveLabel(t){ activeTaskLabel.textContent = t; }

/* -------- Import/Export & Template -------- */
function onExport(){
  const blob = new Blob([JSON.stringify(state, null, 2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url; a.download = `goal-grinder-${todayISO()}.json`;
  document.body.appendChild(a); a.click();
  setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
}
function onImport(e){
  const file = e.target.files?.[0]; if (!file) return;
  const name = (file.name||"").toLowerCase();
  const reader = new FileReader();
  if (name.endsWith(".csv")){
    reader.onload = ()=> importCSV(reader.result);
    reader.readAsText(file);
  } else {
    reader.onload = ()=>{
      try{
        const imported = JSON.parse(reader.result);
        state = imported && imported.sections ? imported : state;
        persist(state, {noHistory:true}); renderAll(); alert("Import complete.");
      }catch{ alert("Invalid JSON."); }
    };
    reader.readAsText(file);
  }
}
function downloadTemplateCSV(){
  const sample =
`Section,Title,Duration,Notes
Sketchy > Micro > 01 Gram Positive Cocci,Staph aureus,08:45,
Sketchy > Micro > 01 Gram Positive Cocci,Strep pyogenes,09:10,
Sketchy > Pharm > Antibiotics — Beta-lactams,Penicillins overview,10:30,
Pathoma > Chapter 1,1.1 Growth adaptations,12:00,
Boards & Beyond > Cardio > Valvular disease,Aortic stenosis,14:20,
`;
  const blob = new Blob([sample], {type:"text/csv"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url; a.download = "bulk-template.csv";
  document.body.appendChild(a); a.click();
  setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
}
function importCSV(csvText){
  const rows = csvToObjects(csvText);
  if (!rows.length){ alert("No rows found."); return; }
  pushUndo();
  let added=0, updated=0, createdSections=0;
  rows.forEach(r=>{
    const obj = normalizeRow(r);
    if (!obj.section || !obj.title) return;
    let sec = ensurePath(obj.section);
    if (!sec){ createdSections++; sec = { id: cryptoId(), title: obj.section, items: [], children: [] }; state.sections.push(sec); }
    const existing = (sec.items||[]).find(i => (i.title||"").trim() === obj.title);
    if (existing){ existing.duration = obj.duration || existing.duration || ""; existing.notes = obj.notes ?? existing.notes ?? ""; updated++; }
    else { (sec.items = sec.items||[]).push({ id: cryptoId(), title: obj.title, duration: obj.duration || "", notes: obj.notes || "", done: false }); added++; }
  });
  persist(); renderAll();
  alert(`Bulk add complete.\nSections created: ${createdSections}\nItems added: ${added}\nItems updated: ${updated}`);
}
function csvToObjects(text){
  const rows = csvToRows(text);
  if (!rows.length) return [];
  const headers = rows[0].map(h => (h||"").trim().toLowerCase());
  const out = [];
  for (let i=1;i<rows.length;i++){
    const row = rows[i]; if (row.every(c => (c||"").trim()==="")) continue;
    const obj = {}; headers.forEach((h,idx)=> obj[h] = (row[idx]||"").trim());
    out.push(obj);
  }
  return out;
}
function csvToRows(str){
  const rows = []; let cur=[], val="", inQuotes=false;
  const s = String(str).replace(/\r\n/g,"\n").replace(/\r/g,"\n");
  for (let i=0;i<s.length;i++){
    const c=s[i], n=s[i+1];
    if (c === '"'){ if (inQuotes && n === '"'){ val+='"'; i++; } else { inQuotes=!inQuotes; } }
    else if (c === ',' && !inQuotes){ cur.push(val); val=""; }
    else if (c === '\n' && !inQuotes){ cur.push(val); rows.push(cur); cur=[]; val=""; }
    else { val += c; }
  }
  cur.push(val); rows.push(cur);
  return rows;
}
function normalizeRow(r){
  const get = k => r[k] ?? r[k?.toLowerCase()] ?? "";
  const choose = keys => keys.map(get).find(v => v!=="") || "";
  return {
    section:  choose(["section","sections"]),
    title:    choose(["title","item","name"]),
    duration: choose(["duration","length","time"]),
    notes:    choose(["notes","note","comment"])
  };
}
function ensurePath(sectionPath){
  // sectionPath can be 'Sketchy > Micro > Bacteria' or 'Sketchy/Micro/Bacteria'
  if (!sectionPath) return null;
  const parts = String(sectionPath).split(/>|\\||\\//).map(s=>s.trim()).filter(Boolean);
  if (!parts.length) return null;
  let parent = null;
  let list = state.sections;
  let node = null;
  for (const name of parts){
    node = (list||[]).find(s => (s.title||'').trim() === name);
    if (!node){
      node = { id: cryptoId(), title: name, items: [], children: [] };
      list.push(node);
    }
    parent = node;
    list = node.children;
  }
  return node;
}

/* -------- Collapse helpers -------- */
function isCollapsed(id){ return !!(state.settings.collapsed && state.settings.collapsed[id]); }
function setCollapsed(id, val){
  state.settings.collapsed = state.settings.collapsed || {};
  state.settings.collapsed[id] = !!val;
  persist(undefined,{noHistory:true});
}
function collapseAll(){ walkSections(sec => { setCollapsed(sec.id, true); }); renderSections(); }
function expandAll(){ walkSections(sec => { setCollapsed(sec.id, false); }); renderSections(); }

/* -------- Events & theme/width -------- */
function setupEvents(){
  searchEl.addEventListener("input", ()=> renderSections());
  dailyGoalEl.addEventListener("input", ()=>{
    pushUndo();
    state.settings.dailyGoalMinutes = Number(dailyGoalEl.value || 0);
    persist(); renderTodayMeta();
  });
  exportBtn.addEventListener("click", onExport);
  importFile.addEventListener("change", onImport);
  resetBtn.addEventListener("click", ()=>{ if (!confirm("This resets ALL data. Continue?")) return; pushUndo(); state = structuredClone(DEFAULT_DATA); persist(); renderAll(); });
  addSectionBtn.addEventListener("click", addSection);
  fillTodayBtn.addEventListener("click", autoFillToday);
  clearTodayBtn.addEventListener("click", clearTodayQueue);
  collapseAllBtn.addEventListener("click", collapseAll);
  expandAllBtn.addEventListener("click", expandAll);
  startTimerBtn.addEventListener("click", ()=>{
    if (state.today.active) return;
    if (state.today.queue[0]) startTimer(state.today.queue[0].sectionId, state.today.queue[0].itemId);
  });
  pauseTimerBtn.addEventListener("click", pauseTimer);
  stopTimerBtn.addEventListener("click", stopTimer);
  templateBtn.addEventListener("click", downloadTemplateCSV);

  themeSelect.addEventListener("change", e=> applyTheme(e.target.value));
  widthSelect.addEventListener("change", e=> applyContainerWidth(parseInt(e.target.value,10)));
  toggleSidepanel.addEventListener("click", ()=>{
    sidepanel.classList.toggle("hidden");
    localStorage.setItem(SIDEPANEL_KEY, sidepanel.classList.contains("hidden") ? "1" : "0");
  });

  // Undo / Redo buttons and shortcuts
  undoBtn.addEventListener("click", onUndo);
  redoBtn.addEventListener("click", onRedo);
  window.addEventListener("keydown", (e)=>{
    const z = e.key.toLowerCase() === "z";
    if ((e.ctrlKey || e.metaKey) && z && !e.shiftKey){ e.preventDefault(); onUndo(); return; }
    if ((e.ctrlKey || e.metaKey) && z && e.shiftKey){ e.preventDefault(); onRedo(); return; }
    // Tab to indent/outdent when a section is selected
    if (e.key === "Tab" && selectedSectionId){
      e.preventDefault();
      if (e.shiftKey) outdentSection(selectedSectionId);
      else indentSection(selectedSectionId);
      return;
    }
  });
}
function applyTheme(name){
  document.body.classList.remove("theme-dark","theme-light","theme-sepia","theme-forest","theme-rose");
  document.body.classList.add(`theme-${name}`);
  localStorage.setItem(THEME_KEY, name);
  if (themeSelect) themeSelect.value = name;
}
function applyContainerWidth(px){
  document.documentElement.style.setProperty("--container-max", (px>=9999? "100vw" : `${px}px`));
  localStorage.setItem(WIDTH_KEY, String(px));
  if (widthSelect) widthSelect.value = String(px);
}

/* -------- Drag & drop (sibling reorder) -------- */
let dragSrcId = null;
function setupDragAndDrop(){
  const root = document.getElementById('sections');
  root.addEventListener('dragover', onDragOver);
  root.addEventListener('drop', onDrop);
}
function addDnDHandlers(cardEl, sec){
  cardEl.addEventListener('dragstart', (e)=>{
    dragSrcId = sec.id;
    cardEl.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
  });
  cardEl.addEventListener('dragend', ()=>{
    cardEl.classList.remove('dragging');
    dragSrcId = null;
  });
  cardEl.querySelector('.children').addEventListener('dragover', onDragOver);
  cardEl.querySelector('.children').addEventListener('drop', onDrop);
}
function onDragOver(e){
  e.preventDefault();
  const childrenWrap = e.target.closest('.children');
  if (childrenWrap){ childrenWrap.classList.add('drophover'); setTimeout(()=> childrenWrap.classList.remove('drophover'), 120); }
  e.dataTransfer.dropEffect = 'move';
}
function onDrop(e){
  e.preventDefault();
  const targetCard = e.target.closest('details.card');
  const dropInChildren = e.target.closest('.children');
  if (!dragSrcId) return;
  const srcCtx = findSectionCtx(dragSrcId);
  if (!srcCtx) return;

  if (!targetCard && dropInChildren){
    // Dropped into a children container without a specific card: move to end of that sibling list (same parent only)
    const parentCard = dropInChildren.closest('details.card');
    const parentId = parentCard ? parentCard.dataset.secId : null;
    const parent = parentId ? findSection(parentId) : null;
    const siblings = parent ? parent.children : state.sections;
    if ((srcCtx.parent?.id || '') !== (parent?.id || '')) return; // only reorder within same parent
    pushUndo();
    const from = srcCtx.siblings.findIndex(s=>s.id===srcCtx.node.id);
    if (from>=0){ srcCtx.siblings.splice(from,1); siblings.push(srcCtx.node); persist(); renderAll(); }
    return;
  }

  if (!targetCard) return;
  const targetId = targetCard.dataset.secId;
  if (dragSrcId === targetId) return;
  const tgtCtx = findSectionCtx(targetId);
  if (!tgtCtx) return;

  // Reorder only among same siblings
  if (String(srcCtx.parent?.id || '') !== String(tgtCtx.parent?.id || '')) return;

  const siblings = srcCtx.siblings;
  const from = siblings.findIndex(s=>s.id===srcCtx.node.id);
  const to = siblings.findIndex(s=>s.id===tgtCtx.node.id);
  if (from < 0 || to < 0 || from === to) return;

  pushUndo();
  const [moved] = siblings.splice(from,1);
  const insertAt = (e.clientY < targetCard.getBoundingClientRect().top + targetCard.offsetHeight/2) ? to : to+1;
  siblings.splice(insertAt > from ? insertAt-1 : insertAt, 0, moved);
  persist(); renderAll();
}

/* -------- Tree helpers -------- */
function findSection(id){
  let found=null;
  walkSections(sec => { if (sec.id===id) found = sec; });
  return found;
}
function findSectionByTitleDeep(title){
  title = (title||"").trim();
  let found=null;
  walkSections(sec => { if ((sec.title||"").trim() === title) found = sec; });
  return found;
}
function findSectionCtx(id){
  // returns {node, parent, siblings, parentCtx}
  let ctx=null;
  function dfs(list, parentCtx){
    for (let i=0;i<list.length;i++){
      const s=list[i];
      if (s.id===id){
        ctx = {node:s, parent: parentCtx ? parentCtx.node : null, siblings: list, parentCtx};
        return true;
      }
      if (s.children && s.children.length){
        if (dfs(s.children, {node:s, parent: parentCtx?parentCtx.node:null, parentCtx})) return true;
      }
    }
    return false;
  }
  dfs(state.sections, null);
  return ctx;
}
function walkSections(fn){
  const dfs = (list)=>{
    list.forEach(s=>{ fn(s); if (s.children && s.children.length) dfs(s.children); });
  };
  dfs(state.sections||[]);
}
function getItem(sectionId, itemId){
  const sec = findSection(sectionId); if (!sec) return null;
  return (sec.items||[]).find(i=>i.id===itemId)||null;
}
function matchesQuery(it,q){ if(!q) return true; return (it.title||"").toLowerCase().includes(q) || (it.notes||"").toLowerCase().includes(q); }
function sumSectionTotalSecondsDeep(sec){
  let sum=0;
  (sec.items||[]).forEach(it=> sum += toSeconds(it.duration||"0"));
  (sec.children||[]).forEach(ch=> sum += sumSectionTotalSecondsDeep(ch));
  return sum;
}
function sumSectionWatchedSecondsDeep(sec){
  let sum=0;
  (sec.items||[]).forEach(it=> sum += (it.done?toSeconds(it.duration||"0"):0));
  (sec.children||[]).forEach(ch=> sum += sumSectionWatchedSecondsDeep(ch));
  return sum;
}
function countDoneTotalDeep(sec){
  let done=0,total=0;
  (sec.items||[]).forEach(it=>{ total++; if (it.done) done++; });
  (sec.children||[]).forEach(ch=>{ const [d,t]=countDoneTotalDeep(ch); done+=d; total+=t; });
  return [done,total];
}
function uncompletedItemsDeep(){
  const out=[];
  walkSections(sec => (sec.items||[]).forEach(it=>{ if(!it.done) out.push({sec,it}); }));
  return out;
}
function totalPlannedMinutes(queue){
  let total=0; queue.forEach(q=>{ const it=getItem(q.sectionId, q.itemId); total += asMinutes(it?.duration || "0"); }); return total;
}
function totalDoneOverallDeep(){
  let done=0,total=0;
  walkSections(sec => (sec.items||[]).forEach(it=>{ total++; if(it.done) done++; }));
  return [done,total];
}
function collectSectionItemPairsDeep(sec){
  const pairs=[];
  (sec.items||[]).forEach(it=> pairs.push({sectionId:sec.id, itemId:it.id}));
  (sec.children||[]).forEach(ch=> pairs.push(...collectSectionItemPairsDeep(ch)));
  return pairs;
}
function calcStreak(){
  const today=todayISO(); state.history[today]=Math.round((state.today.studiedSeconds||0)/60); persist(undefined,{noHistory:true});
  let streak=0; let d=new Date(today);
  while(true){
    const key=d.toISOString().slice(0,10);
    const minutes=state.history[key]||0;
    if(minutes>0){ streak++; d.setDate(d.getDate()-1); } else break;
  }
  return streak;
}
/* ================== end of main JS ================== */
</script>
</body>
</html>
